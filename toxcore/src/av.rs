//! Audio/Video related types

use crate::{error::*, Friend};

use futures::{
    channel::mpsc::{UnboundedReceiver, UnboundedSender},
    pin_mut,
    prelude::*,
    StreamExt,
};

use std::{
    pin::Pin,
    sync::{Arc, RwLock},
    task::{Context, Poll},
};

/// Single frame of audio data
#[derive(Clone)]
pub struct AudioFrame {
    /// Audio data
    ///
    /// This is the raw i16 data going to/from toxcore. This will be interlaced
    /// according to the number of channels
    // Arc here is fairly important for incoming audio frames. Due to the
    // abstractions there is no way for a client to say "send this data to these
    // friends". This is a useful feature to have if your client wants to be able
    // to join multiple calls at a time.
    //
    // We work around this problem by just reference counting the audio data.
    // Callers are free to re-use the same audio data in all call paths now without
    // eating an extra copy cost per friend.
    //
    // In the future if toxav exposes an API to batch the same data to multiple
    // friends, or performance of audio transfer becomes a problem we can
    // re-evaluate
    //
    // Single owner is guaranteed when receiving audio
    pub data: Arc<Vec<i16>>,
    /// Number of channels in data.
    pub channels: u8,
    /// Sample rate in Hz
    pub sample_rate: u32,
}

/// Event generated by an active call handle
pub enum CallEvent {
    AudioReceived(AudioFrame),
    CallStateChanged(CallState),
}

/// Current state of a call
#[derive(Eq, PartialEq, Clone, Copy)]
pub enum CallState {
    /// Indicates that the call is currently sending/receiving data
    Active,
    /// Indicates that the call is over and the call handle should be dropped
    Finished,
    /// Indicates that a peer is waiting for an answer
    WaitingForSelfAnswer,
    /// Indicates that a call has been initiated and is waiting on a peer to answer
    WaitingForPeerAnswer,
}

/// Current state of a call
pub(crate) struct CallData {
    /// Current state
    pub(crate) call_state: CallState,
    /// True if audio is enabled for this call
    pub(crate) _audio_enabled: bool,
    /// True if video is enabled for this call
    pub(crate) _video_enabled: bool,
}

/// Control signal sent from internal call objects to toxcore instance
pub(crate) enum CallControl {
    Accepted,
    SendAudio(AudioFrame),
    Reject,
}

/// Helper struct for IncomingCall. This allows us to implement drop but still
/// move all data to ActiveCall on accept
struct IncomingCallInner {
    control: UnboundedSender<CallControl>,
    event_channel: UnboundedReceiver<CallEvent>,
    friend: Friend,
    data: Arc<RwLock<CallData>>,
}

/// Represents an incoming call.
///
/// A call will be provided as one of many toxcore events
///
/// ```
/// # use toxcore::Event;
/// # fn handle_event(event: Event) {
///     match event {
///         Event::IncomingCall(call) => {
///             let friend = call.friend();
///             println!("Receiving call from {}", friend.name());
///             let call = call.accept();
///             // ...
///         }
///         _ => { /* ... */ }
///     }
/// # }
/// ```
pub struct IncomingCall {
    inner: Option<IncomingCallInner>,
}

impl IncomingCall {
    /// Creates a new incoming call handle
    pub(crate) fn new(
        control: UnboundedSender<CallControl>,
        event_channel: UnboundedReceiver<CallEvent>,
        data: Arc<RwLock<CallData>>,
        friend: Friend,
    ) -> IncomingCall {
        IncomingCall {
            inner: Some(IncomingCallInner {
                control,
                event_channel,
                friend,
                data,
            }),
        }
    }

    /// Retrieves a call handle for the calling friend
    pub fn friend(&self) -> &Friend {
        &self.inner.as_ref().unwrap().friend
    }

    /// Waits for a hangup event. This can be used to propagate back to the UI
    /// that the call is no longer relevant. For example
    /// ```
    /// # use futures::select;
    /// # use futures::channel::mpsc;
    /// # use futures::prelude::*;
    /// # use toxcore::av::{ActiveCall, IncomingCall};
    /// # enum UiEvent {
    /// #     Accept,
    /// #     _Phantom,
    /// # }
    /// # async fn wait_for_events(mut ui_channel: mpsc::UnboundedReceiver<UiEvent>, mut incoming_call: IncomingCall) -> Result<ActiveCall, toxcore::error::ExpiredError> {
    ///     futures::select! {
    ///         _  = incoming_call.wait_hangup().fuse() => {
    ///             // ... drop call and send notification to user
    ///             # unreachable!();
    ///         }
    ///         ui_event = ui_channel.next().fuse() => {
    ///             match ui_event {
    ///                 AcceptCall => return incoming_call.accept(),
    ///                 _ => { /* ... */ },
    ///             }
    ///         }
    ///     }
    /// #   unreachable!()
    /// # }
    /// ```
    pub fn wait_hangup(&mut self) -> impl Future<Output = ()> + '_ {
        self.inner
            .as_mut()
            .unwrap()
            .event_channel
            .next()
            .inspect(Self::assert_is_call_ended)
            .map(|_| ())
    }

    /// Accepts the incoming call, consuming it and returning an [`ActiveCall`]
    pub fn accept(mut self) -> Result<ActiveCall, ExpiredError> {
        if self.check_hangup() {
            return Err(ExpiredError);
        }

        let inner = self.inner.take().unwrap();

        inner
            .control
            .unbounded_send(CallControl::Accepted)
            .map_err(|_| ExpiredError)?;

        Ok(ActiveCall::new(
            inner.control,
            inner.event_channel,
            inner.data,
        ))
    }

    /// Helper function to ensure when toxcore notifies us of an event it is the
    /// only event we expect
    fn assert_is_call_ended(event: &Option<CallEvent>) {
        match event {
            Some(CallEvent::CallStateChanged(CallState::Finished)) | None => (),
            _ => panic!("Invalid call state"),
        }
    }

    /// Checks if we've previously received a hangup
    fn check_hangup(&self) -> bool {
        self.inner.as_ref().unwrap().data.read().unwrap().call_state == CallState::Finished
    }

}

impl Drop for IncomingCall {
    fn drop(&mut self) {
        if let Some(inner) = &mut self.inner {
            // If our handle outlives our tox instance this is useless anyways
            let _ = inner.control.unbounded_send(CallControl::Reject);
        }
    }
}

/// Represents a live call with a friend. If this handle is available operations
/// with toxcore should be available. This handle represents that a user wants
/// to participate in a call, but does not necessarily mean that the peer has
/// picked up.
///
/// NOTE: ActiveCall acts as a future stream to receive events from the remote
/// side. This stream must be consumed or the event backlog may become too long
///
/// ```
/// # use toxcore::av::{ActiveCall, CallEvent, IncomingCall};
/// # use futures::prelude::*;
/// # async fn service_call(incoming_call: IncomingCall)  -> Result<(), Box<dyn std::error::Error>> {
///     let mut call = incoming_call.accept()?;
///     while let Some(event) = call.next().await {
///         match event {
///             CallEvent::AudioReceived(frame) => { /* dispatch audio frame */ },
///             CallEvent::CallStateChanged(state) => { /*propagate call state, drop call if finished*/ },
///         }
///     }
/// # Ok(())
/// # }
/// ```
pub struct ActiveCall {
    control: UnboundedSender<CallControl>,
    event_channel: UnboundedReceiver<CallEvent>,
    data: Arc<RwLock<CallData>>,
}

impl ActiveCall {
    pub(crate) fn new(
        control: UnboundedSender<CallControl>,
        event_channel: UnboundedReceiver<CallEvent>,
        data: Arc<RwLock<CallData>>,
    ) -> ActiveCall {
        ActiveCall {
            control,
            event_channel,
            data,
        }
    }

    /// Returns the current state of the call
    pub fn call_state(&self) -> CallState {
        self.data.read().unwrap().call_state
    }

    /// Sends an audio frame to the peer
    pub fn send_audio_frame(&self, frame: AudioFrame) -> Result<(), ExpiredError> {
        self.control
            .unbounded_send(CallControl::SendAudio(frame))
            .map_err(|_| ExpiredError)?;
        Ok(())
    }
}

impl Stream for ActiveCall {
    type Item = CallEvent;

    fn poll_next(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<Self::Item>> {
        let this = self;
        pin_mut!(this);
        this.event_channel.poll_next_unpin(cx)
    }
}

impl Drop for ActiveCall {
    fn drop(&mut self) {
        let _ = self.control.unbounded_send(CallControl::Reject);
    }
}
